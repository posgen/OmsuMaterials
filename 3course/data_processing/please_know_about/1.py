'''
    Часть единственная: базовые структуры данных pandas.

    ------------------------------------------------------------------------
    Поскольку экзамен назначили в 235, а там с ПО сложновато, всё немного упрощается.
    Вместо кучи файлов - один единственный с обязательным содержимым для тех, кому
    неинтересно переносить сдачу экзамена на осенний период.

    Вся информация ниже - необходима (не факт, что достаточна) для прохождения экзамена.
    В первую очередь концентрируемся на том, чтобы уметь демонстрировать самостоятельно,
    своими руками, те основы работы с инструментом, что излагаются ниже. Остальные детали
    - на консультации. Кстати, не забываем про какой-то там набор заданий из семестра. 
    ------------------------------------------------------------------------

    pandas - библиотека для обработки и анализа двумерных (табличных) данных. Для примера, рассмотрим набор:
        
        | 4 | 3.5 | "AB" | 2022-02-09 |
        | 6 | 1.8 | "CD" | 2022-02-13 |
        | 7 | 8.4 | "WX" | 2022-02-13 |
        | 8 | 2.5 | "QN" | 2022-02-26 |

    Простая таблица из четырёх столбцов и четырёх строк, которая может создана программным образом, храниться в Excel-подобных 
    табличных редакторах, загружаться из баз данных. pandas даёт инструменты для выборки части данных из исходного набора, их группировки,
    их расширения, проведения статистических расчётов. Предоставляются функции для различных типов данных - численных, строковых, дат, 
    временных меток (дата + время) и прочих. И даже визуализация, встроенная в библиотеку, прилагается.

    Для удобства работы, pandas ко всем строкам и столбцам применяет концепцию расширенной индексации: каждая строка или столбец получает 
    свою метку (label). Структура исходных данных в рамках логики pandas становится:

                            столбец
                               |
                               v
                          __________
                         /          \  
                        |[label_col1]|   [label_col2] [label_col3]  [label_col4]
        { [label_row1] ||      4     | |     3.5     |     "AB"   |  2022-02-09  | } <- строка 
          [label_row2] ||      6     | |     1.8     |     "CD"   |  2022-02-13  |
          [label_row3] ||      7     | |     8.4     |     "WX"   |  2022-02-13  |
          [label_row4] ||      8     | |     2.5     |     "QN"   |  2022-02-26  |
                         \___________/

          \______________________________________________________________________/
                                            |
                                            v
                    объект типа DataFrame (pandas.DataFarame, с учётом имени модуля)

    Метками также могут быть различные типы данных. Технически говоря, метки индексируют столбцы
    и строки какими-то значениями.

    Исходные данные + два набора меток (для строки и столбцов, соответственно) в рамках библиотеки 
    представляются объектом типа - DataFrame. Это как раз представление 2D структуры данных с индексами 
    по обоим направлениям.

    Каждый столбец исходных данных представлен в виде объекта типа Series - одномерного проиндексированного 
    массива. На примере исходных данных, графически объект Series для третьей колонки можно изобразить как:

        [label_row1] | "AB" |
        [label_row2] | "CD" |
        [label_row3] | "WX" |
        [label_row4] | "QN" |
        \___________________/
                  |
                  v
      объект типа Series (pandas.Series)

    Для третьего столбца такой объект хранит 4 значения (строки а-ля "AB", ... выше) и позволяет обращаться
    к ним не только с помощью целочисленных индексов, но и с помощью соответствующих меток.

    Далее идут детали работы с объектами Series и DataFrame. Для начала, загружаем нужные пакеты Python'а
'''
import numpy as np # необязятелен, используется для примеров
import pandas as pd

'''
    Работа с объектами Series.

    Вручную объект типа Series создаётся путём передачи в конструктор типа некоторых данных. Общая форма:
        
        pd.Series(data, index=index)

    Аргумент с именем *index* является опциональным. *data* может быть объектом различных типов данных:
        -> обычный питоновский список
            pd.Series([3, 4, 8, 5])

        -> словарь
            pd.Series({'a': 4.5, 'b': -3.5, 'c': 6.7})
        !! при таком способе создания серии, ключи словаря становятся - метками, а значения - элементами хранимого 
        массива !!

        -> массивом ndarray из библиотеки numpy
            pd.Series(np.randn(5, dtype=float), index=['col1', 'col2', 'col3', 'col4', 'col5'])
            pd.Series(np.random.randn(3), index=['energy', 'mass', 'density'])

        -> объект, представляющий скаляр (единственное значение):
            pd.Series(78)
            pd.Series('my talk to world')

        -> другой объект типа Series
            first = pd.Series([3, 4, 8, 5])
            second = pd.Series(first)
            third = pd.Series(first, index=[0, 2, 3])
        Аргумнент *index* в данном контексте задаёт те индексы, которые будут взяты из исходного набора данных
'''
# Для примера, пусть есть список со значениями:
some_list = ['AB', 'CD', 'WX', 'QN']
print(f"[Шаг 1] Данные для примера: {some_list}\n")

# Создаём объект Series
first_series = pd.Series(some_list)
print(f"[Шаг 2] серия:\n{first_series}\n")

'''
    При создании объекта не был задан опциональный аргумент *index*. В этом случае, pandas создаёт целочисленный
    индекс для переданного набора данных. Метки получают значения 0, 1, 2, ... и так далее с шагом 1. 
    Схематично выглядит так:

        0 | "AB" |
        1 | "CD" |
        2 | "WX" |
        3 | "QN" |
        \________/
            |
            v
        first_series

    Узнать, что за тип используется в качестве индекса (да и значения подсмотреть), можно запросив у объекта 
    атрибут *index*. В данном случае, тип индекса будет - RangeIndex, который представляет собой простой
    целочисленный диапазон с шагом 1.
'''
print(f"[Шаг 3] индекс созданной серии: {first_series.index}\n")

'''
    Поскольку серия представляет собой одномерный массив, ей доступен оператор индексации для получения/изменения
    значений набора данных. В качестве индекса, как и со стандартными перечислимыми объектами python'а, может 
    выступать либо значение конкретной метки, либо срез (slice).
'''
print(f"[Шаг 4] третий элемент first_series: {first_series[2]}\n")

'''
    Для демонстрации работы со срезами, создадим ещё один объект Series и вручную зададим индексы, на этот раз -
    строковые. При создании серии из стандартного python'ого списка количество элементов в нём и в списке 
    для индексации должны совпадать.
'''
second_series = pd.Series([5.5, 1.5, 4.5, 3.7, 9.95], index=['a', 'b', 'c', 'd', 'e'])
print(f"[Шаг 5] ещё одна серия:\n{second_series}\n")

'''
    Теперь к элементам серии *second_series* можно обращаться через оператор индексации ("[]", он же - 
    квадратные скобки) используя и целочисленный, и строковый индексы.

    Плюс нюанс индексации: если индекс набора данных выбран библиотекой pandas по умолчанию (RangeIndex выше),
    то к нему невозможно применить отрицательную индексацию (как в стандартном списке в python). А вот для
    примера со строковым индексом - можно.
'''
print(f"[Шаг 6] доступ по строковому индексу: {second_series['d']}")
print(f"[Шаг 6] доступ по целочисленному индексу: {second_series[2]}\n")
print(f"[Шаг 6] последний элемент second_series: {second_series[-1]}\n")

'''
    Для получения нескольких значений серии применяются срезы (ака диапазоны). Значениями индексов среза
    выступают как целые числа, так и значения меток набора данных. 

    Основные особенности: 
        -> для целочисленных срезов правая граница не включается в получающийся набор данных, 
        для остальных типов значений - включается;

        -> если используются нецелочисленные индексы, то порядок их следования должен соблюдаться.
'''
print(f"[Шаг 7] целочисленный срез:\n{first_series[0:3]}\n===========")
print(f"[Шаг 7] снова он:\n{second_series[0:3]}\n===========")
print(f"[Шаг 7] строковый срез:\n{second_series['a':'d']}\n===========")
print(f"[Шаг 7] срез [-3:-1]:\n{second_series[-3:-1]}\n===========")
print(f"[Шаг 7] срез ['d':'a']:\n{second_series['d':'a']} (пустая серия, не содержащая ни одного элемента)\n")

'''
    С помощью индексации по меткам/целочисленным_индексам меняются или добавляются в наборе данных.

    Стоит заметить, что pandas достаточно гибко подходит к наборам данных и тем операциям, что с ними происходят.
    Так, после следующих изменений, объект *first_series* "поменяет"" самостоятельно тип индекса.
'''
first_series[5] = 'QQ'
print(f"[Шаг 8] индекс first_series теперь:\n{first_series.index}")
print(f"[Шаг 8] опять срез:\n{first_series[0:5]}")
 
second_series['c'] = -2.3 # поменяли значение в рамках сохранённого набора данных
second_series['g'] = 0.58 # добавили новый элемент в набор данных
print(f"[Шаг 8] second_series:\n{second_series}\n")

'''
    К объектам Series применяются векторизованные вычисления. Под таковыми понимают ситуации, когда применение 
    некоторых функций и/или математических операторов к некоторому объекту, представляющим собой набор данных,
    приводит к поэлементному выполнению этих самых функций и/или операторов.

    На практике, для объектов типа Series векторизованные вычисления применяются к каждой метке исходного набора
    данных. Если для какой-то метки невозможно выполнить требуемую операцию, то в итоговой серия соответствующей 
    метке будет проставлено значение NaN (изначально - "not-a-number", но в контексте pandas может означать и 
    значение, полученное в результате недопустимой операции, и - отсутствующие данные).
'''
# ещё одна серия для примеров
third_series = pd.Series([4.4, -2.3, -1.5], index=['b', 'd', 'e'])
print(f"[Шаг 9] сумма серии (сама с собой):\n{second_series + second_series}")
print(f"[Шаг 9] сумма серий (разные индексы):\n{second_series + third_series}")
print(f"[Шаг 9] сумма серий (строковые значения):\n{first_series + first_series}\n===========")
exp_values = np.exp(second_series)
print(f"[Шаг 9] вычисление экспоненты на наборе:\n{exp_values}")
exp_values = np.sin(second_series)
print(f"[Шаг 9] или какая-нибудь тригонометрия:\n{exp_values}")
# Далее будет возвращена серия, значениями элементов которо будут логические значения -
# True или False. В зависимости от того, выполняется ли операция сравнения или нет.
print(f"[Шаг 9] применение операций сравнения:\n{exp_values < 0}\n")

'''
    Кроме целочисленных и строковых индексов, при обработке различных данных часто используются метки, представляющие
    собой какой-либо набор дат с различной степенью точности: минуты, часы, дни, недели, месяцы и прочее.

    Для создания такого индекса вручную в pandas присутствует функция - date_range:
        pd.date_range(start='2022-05-01 12:30:00', end='2022-05-01 12:45', freq='5min')
    у которой три основных параметра:
        -> start - дата начала временного диапазона;
        -> end   - конец временного диапазона;
        -> freq  - частота диапазона, то есть интервал между соседними значениями в индексе (выше - 5 минут, "5min").
                   По умолчанию, без явного указания периодом является 1 день.
                   Возможные варианты тут - https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases

    Сами даты могут указываться в различных форматах, вида 'yyyy-mm-dd', как выше, или, скажем, 'dd/mm/yyyy'.

    Один из параметров - start или end - может быть пропущен. В таком случае, вместо частоты диапазона нужно указать, 
    сколько значений должно входить в индекс:
        pd.date_range(start='2022-04-01', periods=8)
    В такой форме параметр *periods* означает количество дней после (и включая) заданной даты. Аналогичная форма:
        pd.date_range(end='2022-04-01', periods=8)
    создаст 8 дат, с частотой в один день, последняя из которых равна 1 апреля 2022 года.

    Для примера: создание серии, индексом которой выступает набор дат. Пусть будет температура в 12:00 за некий набор дней
'''
weather_series = pd.Series([19, 17, 15, 11, 15, 18, 20, 22], index=pd.date_range(start='2022-06-01', end='2022-06-08'))
print(f"[Шаг 10] weather_series:\n{weather_series}")
# Получение данных по конкретному индексу:
print(f"[Шаг 10] на дату {'2022-06-06'}  была температура: {weather_series['2022-06-06']}")
# использование объекта типа datetime из стандартной питоновской библиотеки для
# доступа к конкретному элементу серии:
from datetime import datetime
fouth_june = datetime(2022, 6, 4)
print(f"[Шаг 10] а на дату {fouth_june.strftime('%d/%m/%y')}  была температура: {weather_series[fouth_june]}")
# и ещё раз - через квадратные скобки можно получить элемент серии по порядковому индексу (нумерация с 0):
print(f"[Шаг 10] пятая температура в наборе: {weather_series[4]}\n")

'''
    Кроме доступа к значениям через оператор индексации (ака квадратные скобки), pandas предоставляет ещё два атрибута
    для объектов типа Series (да и DataFrame):
        -> .loc  - получение элемента исключительно по значени-ю(-ям) индекса;
        -> .iloc - получение элемента по его позиции в наборе (применение целочисленных индексов).
    Оба атрибута возвращают некоторые прокси-объекты, к которым в свою очередь применяется оператор индексации:
        weather_series.loc['2022-06-02']
        weather_series.iloc[2]
'''
print(f"[Шаг 11] пример loc, один элемент серии: {weather_series.loc['2022-06-03']}")
print(f"[Шаг 11] пример loc, выбор через срез:\n{weather_series.loc['2022-06-02':'2022-06-05']} <- pandas созадёт новую серию")

print(f"[Шаг 11] пример iloc, один элемент серии: {weather_series.iloc[4]}")
print(f"[Шаг 11] пример iloc, выбор через срез:\n{weather_series.iloc[2:]} <- pandas созадёт новую серию")
# Также можно поменять конкретное значение через все способы доступа к элементам:
weather_series.loc['2022-06-03'] += 1
weather_series.iloc[0] = 18
weather_series['2022-06-04'] = 10
print(f"[Шаг 11] weather_series после изменений:\n{weather_series}\n")

'''
    Работа с DateFrame.

    Логически, любой объект DataFrame объединяет в себе набор объектов типа Series в качестве столюцов + добавление
    индекса (набора меток) для каждой строки. И базовая работа с ним не сильно различается от всего того, что 
    выше продемонстрированно для серий. Разве что, стоит помнить что размерность поменялась - был одномерный
    набор данных, стал - двухмерный.

    Далее - различные способы создания объектов DataFrame.
'''
# из словаря объектов Series
source_data = {
    "one": pd.Series([1.0, 2.0, 3.0], index=["a", "b", "c"]),
    "two": pd.Series([1.0, 2.0, 3.0, 4.0], index=["a", "b", "c", "d"]),
}
df = pd.DataFrame(source_data)
print(f"[Шаг 12] создание объекта DataFrame (1):\n{df}")
# ! Ключи словаря становятся метками столбцов.

# выбор строк вручную с помощью явного указания
print(f"[Шаг 12] создание объекта DataFrame (2):\n{ pd.DataFrame(source_data, index=['d', 'b', 'a']) }")

# указание вручную конкретных ключей словаря:
print(f"[Шаг 12] создание объекта DataFrame (3):\n{pd.DataFrame(source_data, index=['a', 'c', 'b'], columns=['two', 'three'])}")

# из словаря списков:
source_data = {"1st": [1.0, 2.0, 3.0, 4.0], "2nd": [4.0, 3.0, 2.0, 1.0]}
print(f"[Шаг 12] создание объекта DataFrame (4):\n{pd.DataFrame(source_data)}")
print(f"[Шаг 12] создание объекта DataFrame (5):\n{pd.DataFrame(source_data, index=['w', 'ww', 'www', 'wwww'])}")

# из списка каких-нибудь составных объектов (в данном случае - кортежей (tuple))
source_data = [(1, 2.0, "Важная заметка"), (2, 3.0, "Неважная заметка")]
print(f"[Шаг 12] создание объекта DataFrame (6):\n{pd.DataFrame(source_data)}")

df = pd.DataFrame(source_data, columns=["A", "B", "C"], index=["2022-04-06", "2022-04-07"])
print(f"[Шаг 12] создание объекта DataFrame (7):\n{df}")

# из другого объекта DataFrame
print(f"[Шаг 12] создание объекта DataFrame (7):\n{pd.DataFrame(df, columns=['C', 'B'])}\n")

'''
    У объекта DataFrame всегда можно получить значения меток как строк, так и столбцов:
'''
print(f"[Шаг 13] индекс строк:\n{df.index}")
print(f"[Шаг 13] индекс столбцов:\n{df.columns}")
'''
    на этом не будем останавливаться, но оба объекта выше (индекс строк, индекс столбцов)
    представляют собой стандартные перечислимые объекты python'а. Например, так можно отобразить
    значение каждой метки столбцов:
        for label_value in df.columns:
            print(label_value)
'''

'''
    Для доступа к столбцам или строкам доступна таже тройка атрибутов: [], loc, iloc. Но работают они чуть хитрее,
    чем с объектам Series. Основные правила:

                    Что нужно?                                Синтаксис              Объект какого типа возвращается
        -> (1) выбор столбца по его метке:              |   df[col_label]         |          Series
        -> (2) выбор строки по её метке:                |   df.loc[row_label]     |          Series
        -> (3) выбор строки по целочисленному индексу:  |   df.iloc[row_idx]      |          Series 
        -> (4) выбор среза строк                        |   df[idx_start:idx_end] |         DataFrame 
        -> (5) выбор строк через логический вектор      |   df[boolean_list]      |         DataFrame

    (5) - это специальная форма, где в оператор индексации можно передать список логических значений, а-ля 
    *[True, False, False, True, False]*, в результате которой будут выбраны только те строки, которые соответствуют
    значениям True в переданном списке. На этой форме основана большая часть по фильтрации данных при работе с pandas.

    Кроме того, везде, где возвращаемым объектом является объект DataFrame, мы получаем копию исходных данных, которую
    можно менять независимо от исходного набора данных.
'''