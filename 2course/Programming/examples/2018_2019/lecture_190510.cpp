#include <algorithm>
#include <cmath>
#include <iostream>
#include <random>
#include <string>

/**
    Демонстрация идиомы "функциональный объект" в C++.

    Функциональным объектом в C++ называют объект некоторого класса,
    у которого перегружен оператор 'круглые скобки'. В этом случае
    работа с переменными класса по синтаксису аналогична вызову функций.
    Идея следующая:
        class FuncType
        {
        public:
            int operator()(int i, int j);
        };

        FuncType f1;
        int num = f1();
    Для оператора 'круглые скобки' нет никаких ограничений на тип возвращаемого
    значения и количества передаваемых параметров.

    В литературе по C++ функциональный объект также известен под названием "функтор" (functor).

    Для демонстрации далее расматриваются три тестовых примера:
        1. Выдуманный одномерный потенциал для некоторых расчётов.
        2. Передача функтора в функцию сортировки из библиотеки <algorithm>.
        3. Реализация алгоритма хеширования Пирсона (Pearson hasing) для строк.
*/


/**
    1. Одномерный потенциал:

                 alpha^2 + tg(alpha)        alpha * sin(alpha)
        U(x) = -----------------------  +  -----------------------
                         x                      x * x * x

    Здесь *x* - переменная, *alpha* - просто является параметром.
    Выгода от использования функционального объекта вместо обыкновенной функции с
    парой параметров может проявиться при некоторых долгих вычислениях, когда
    для фиксированного параметра *alpha* потенциал может быть вычислен в миллионах
    или миллиардах разных точек.

    Для оптимизации параметр *alpha* будет сделан полем класса. В момент создания
    объекта класса будут вычисляться выражения для каждого слагаемого. И при вызове
    перегруженного оператора они будут играть роль констант, т.е.:
                 C1           C2
        U(x) = ------  +  -----------
                  x        x * x * x

    Все методы и конструктор класса отдельно определены после функции main.
*/
class UFunc
{
public:
    /// Конструктор
    UFunc(double alpha);

    /// Перегруженный оператор
    double operator()(double x) const;

    /// Метод для доступа к сохранённому параметру
    double alpha() const;

    /// Метод для обновления параметра alpha
    void alpha(double new_value);

private:
    /**
        Поля:
            _alpha - хранение параметра потенциала
            _c1 - выражение из первого слагаемого
            _c2 - из второго.
    */
    double _alpha, _c1, _c2;
};


/**
    2. Передача функтора в функцию сортировки из библиотеки <algorithm>.

    Пусть есть массив строк, он хранит только числа с плавающей точкой.
    Нужно сортировать его в порядке возрастания или убывания.

    Для этого заведём класс, приватным полем будет булевский параметр,
    который будет обозначать, сортируем ли по возрастанию или наоборот.
*/
class StrAsDoubleComparator
{
public:
    /// Перегруженный оператор
    bool operator()(std::string left, std::string right);

    /// Методы для проверки порядка сортировки
    bool is_asc_order() const;
    bool is_desc_order() const;

    /// Метод для изменения порядка сортировки
    void change_order();

private:
    /// По умолчанию сортируется в порядке возрастания значений.
    bool _asc_order = true;
};


/**
    3. Реализация алгоритма хеширования Пирсона (Pearson hasing) для строк.

    Описание можно глянуть даже тут: https://en.wikipedia.org/wiki/Pearson_hashing

    Вкратце, это алгоритм перевода произвольного числа символов в значение от 0 до 255
    (2^8 или 256 вариантов). Для этого используется таблица значений от 0 до 255, перетасованных
    случайным образом.

    Реализуем хеширование произвольной строки в 8-байтовый хеш (диапазон значений - [0; 2^64 - 1]).
    Для этого 8 раз повторяем алгоритм Пирсона, каждый раз записываем итоговое значение в виде
    16-ричного целого числа, а затем получившуюся комбинацию 8 байт привести к типу size_t.
*/
class PearsonHash64
{
public:
    PearsonHash64();

    /// Аналогично стандартной библиотеке, хеш будет возвращаться в виде
    /// 8-байтого целого числа
    size_t operator()(const std::string& str);
    /// С помощью этого метода можно узнать и строковое значения хеша.
    std::string last_str_value() const;

private:
    unsigned char _tbl[256] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
        21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
        58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
        77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
        96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
        128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
        144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
        160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
        176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
        192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
        208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
        224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
        240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
    };

    std::string _str_hash;
};


int main()
{
    using namespace std;

    UFunc u1{0.25}, u2{1.5}, u3{-0.5};
    cout << "x \t U(alpha = " << u1.alpha() << ")"
         << "\t U(alpha = " << u2.alpha() << ")"
         << "\t U(alpha = " << u3.alpha() << ")" << endl;

    /// Табулирование трёх потенциалов
    for (double x = -2.5; x <= 2.5; x += 0.05) {
        /// Использование функциональных объектов подобно вызову функций
        cout << x << "\t" << u1(x) << "\t" << u2(x) << "\t" << u3(x) << endl;
    }
    /*************************************************************************/

    string strings[6] = {"-4.5993", "2.3434", "-10.99", "501.222424224", "3.456", "102.88892"};
    StrAsDoubleComparator compr;
    /// Сортировка по возрастанию
    sort(strings, strings + 6, compr);
    cout << "По возрастанию:\n";
    for (const auto& str : strings) {
        cout << "  " << str << endl;
    }

    compr.change_order();
    /// Сортировка по убыванию
    sort(strings, strings + 6, compr);
    cout << "По убыванию:\n";
    for (const auto& str : strings) {
        cout << "  " << str << endl;
    }
    /*************************************************************************/

    PearsonHash64 hasher;
    size_t hsh1 = hasher("abcdefg");

    string another = "abcdefg";
    cout << hsh1 << " == " << hasher(another) << endl;

    size_t hsh2 = hasher("что-тут");
    cout << hsh2 << ", " << hasher.last_str_value() << endl;
}

UFunc::UFunc(double alpha) : _alpha{alpha}
{
    _c1 = _alpha * _alpha + std::tan(_alpha);
    _c2 = _alpha * std::sin(_alpha);
}

void UFunc::alpha(double new_value)
{
     _alpha = new_value;
    _c1 = _alpha * _alpha + std::tan(_alpha);
    _c2 = _alpha * std::sin(_alpha);
}

double UFunc::alpha() const
{
    return _alpha;
}

double UFunc::operator()(double x) const
{
    return _c1 / x + _c2 / (x * x * x);
}
/*************************************************************************/
bool StrAsDoubleComparator::operator()(std::string left, std::string right)
{
    if (_asc_order) {
        return std::stod(left) < std::stod(right);
    }

    return std::stod(left) > std::stod(right);
}

bool StrAsDoubleComparator::is_asc_order() const
{
    return _asc_order;
}

bool StrAsDoubleComparator::is_desc_order() const
{
    return !_asc_order;
}

void StrAsDoubleComparator::change_order()
{
    _asc_order = !_asc_order;
}
/*************************************************************************/
PearsonHash64::PearsonHash64()
{
    std::mt19937 gnr{ time(nullptr) };
    /**
        shuffle - функция из <algorithm>, которая переставляет элементы
        массива случайным образом с помощью ГПСЧ.
    */
    std::shuffle(_tbl, _tbl + 256, gnr);
}

size_t PearsonHash64::operator()(const std::string& str)
{
    std::ostringstream out;
    out << "0x" << std::hex;

    unsigned char hsh_value;
    size_t obj_length = str.length();

    for (size_t i = 1; i <= 8; i++) {
        hsh_value = _tbl[(str[0] + i) % 256];

        for (size_t j = 1; j < obj_length; j++) {
            hsh_value = _tbl[hsh_value ^ static_cast<unsigned char>(str[j])];
        }

        out << int(hsh_value);
    }

    _str_hash = out.str();

    return std::stoull(_str_hash, nullptr, 0);
}

std::string PearsonHash64::last_str_value() const
{
    return _str_hash.substr(2);
}
