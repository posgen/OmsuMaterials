/**
    Пример на использование статических массивов.

    Программа для игры в блэкджек (упрощённая версия: 1 игрок против комьютера, который и делает раздачу карт)
    ((подробней о правилах: https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D1%8D%D0%BA%D0%B4%D0%B6%D0%B5%D0%BA))


    Что было переделано, по сравнению с аудиторной версией:
        - печать статистики переехала в функцию *show_stat*
        - несколько поменялись условия после окончания добора карт игроком

    ЧТО НУЖНО СДЕЛАТЬ подгруппе прикладников к 26.10.2018:
        1. Когда карта выбирается, желательно знать её индивидуальный вес для просчёта дальнейших шагов.
           Продумать и добавить вывод веса карты в текстовый терминал при каждом вызове функции **get_card*

        2. Добавить возможность игры последовательно в несколько сеансов раздачи карт.
           Это означает, что после окончания одного розыгрыша, спросить игрока о том,
           желает ли он повторить. В случае утвердительного ответа, вернуть массив,
           отвечающий за колоду в первоначальное состояние и повторить игровой сеанс.

        3*. Продумать и реализовать аналог ставок.
            Скажем, банк может ставить случайную сумму от 5 до 20 условных единиц.
            Игрок задаёт свой баланс, и он в ставке произволен - от 1 до максимума, который
            им же и задан. Тогда, в случае выйгрыша - игрок получает свою ставку плюс ставку банка,
            в случае проигрыша - обе ставки получает банк, в случае ничьей - ставки возращаются
            каждой стороне.
            Если получится реализовать пункт 2, то в конце всех сеансов подбить итоги: сколько выйграл/проиграл игрок,
            сколько банк.
            Договоримся, что игрок может уходить в минус не более, чем на 50 условных единиц.
            Банк считаем бездонным.

        Звёздочка "*" в третьем заданнии означает, что продумавание этого пункта - обязательно (то есть - какие
        переменные и/или функции нам нужны, чтобы реализовать написанные в пункте хотелки). Реализация - желательно,
        но не критично, если не будет сделана.

        4[опционально]. Сделать более эстетичный вывод сообщений
*/
#include "ffhelpers.h"

using namespace std;
using namespace ffomsu;

/**
    Функция, принимающая индекс карты в массиве и возращающая её вес.

    Входные параметры:
        *index* - собственно индекс массива карт.

    Возращаемое значение:
        вес карты, расположенной на месте, имеющм индекс - *index*
*/
int vibor( size_t index)
{
    if (index <= 8) {
        return index + 2;
    }

    if (index==12) {
        return 11;
    }

    return 10;
}

/**
    Функция, отвечающая выбирающая случайным образом карту из колоды.
    Следит за тем, чтобы каждая карты из 52 была выбрана только один раз.

    Входные параметры:
        *cld* - массив карт на 52 элемента.

    Возращаемое значение:
        вес случайно выбранной карты.
*/
int get_card(bool (&cld)[52])
{
    size_t index;
    while (true)
    {
        index=rand_a_b_incl(1, 52);

        if (cld[index-1])
        {
            continue;
        }
        else
        {
            cld[index-1]=true;
            break;
        }
    }
    return vibor(index % 13);
}

/**
    Функция для вывода текущего счёта в текстовый терминал.

    Входные параметры:
        *sum_player* - текущий счёт игрока
        *sum_bank*   - он же, но для банка

    Возращаемое значение:
        отсутствует
*/
void show_stat(int sum_player, int sum_bank)
{
    print("Игрок: ", sum_player, " Банк: ", sum_bank, "\n");
}

int main()
{
    /**
        Массив из 52-элементов, соответствующих колоду карт.
        Каждый элемент может быть равен false, если карты не была ещё выбрана,
        иначе он равен true.
    */
    bool coloda[52] = {false};
    int summa_player = 0, summa_bank = 0;

    summa_player = get_card(coloda) + get_card(coloda);
    summa_bank = get_card(coloda);
    show_stat(summa_player, summa_bank);

    if (summa_player==21 or summa_player==22) {
        print("игрок победил\n");
    } else {
        char choice = 'y';
        while(choice != 'n') {
            print("Продолжим?(y/n): ");
            get_value(choice);
            if (choice=='n') {
                break;
            }

            summa_player += get_card(coloda);
            show_stat(summa_player, summa_bank);
            if (summa_player>21) {
                break;
            }
        }

        if (summa_player == 21) {
            print("Безоговорачная победа игрока!\n");
        } else if (summa_player <= 21) {
            summa_bank+=get_card(coloda);

            while(true) {
                summa_bank+=get_card(coloda);
                show_stat(summa_player, summa_bank);

                if (summa_bank>=17) {
                    break;
                }
            }

            if (summa_player==summa_bank) {
                print("ничья\n");
            } else {
                /// Всё-таки в следующем if-е надо проверять на отрицательность <-- Извините, тут ерунда написана
                if ( (summa_player-summa_bank) < 0 ) {
                    print("Ура, победа!");
                } else {
                    print("Проиграл ");
                }
            }

        } else {
            print("Проиграл ");
        }
    }
}
