#include <iostream>
#include <iomanip>
#include <sstream>
#include <string>
#include <cmath>

using namespace std;

/**
    Создаётся псевдоним *fun_x_t* для типа: !указатель-на-функцию, принимающей один параметр
    действительного типа и возращающей какое-то значение того же самого типа.

    Тип возращаемого значения - это первый *double* справа от знака *равно*.
    Тип параметра - указан во вторых круглых скобках.
    *Звёздочка* в первых круглых скобках - специальная синтаксическая конструкция для
    обозначения типа *указатель-на-некоторую-функцию*
*/
using func_x = double (*)(double);

double x_in_3(double x)
{
    return x*x*x;
}

/**
    Пример простейшего численного нахождения первой производной от функции
    одного аргумента.

    Функция принимает два параметра:
        *fn* - переменная-указатель типа *указатель-на-функцию одного параметра*.
               Сама по себе эта переменная и позволяет передать в функцию *derivative*
               любую другую функцию, которая принимает параметр типа *double* и возращает
               значение такого же типа.

        *x* - точка, в которой будет вычислена производная (любое действительное число)
*/
double derivative(func_x fn, double x0)
{
    const double h = 1.0E-7;
    /**
        Работа с переменной-указателем-на-функцию происходит аналогично вызову любой функции:
        к самой переменной применяют круглые скобки (которые, строго говоря, являются оператором
        в C++), в скобках указыаются нужные аргументы.

        Так, синтаксис *fn(4.0)* ничем не отличается от определённой выше функции fun: *fun(4.0)*.
        Но теперь, в данную функцию *derivative* могут попасть любые функции, соответствующие
        объявленному типу, а не одна конкретная, которая была определена заранее.
    */
    return (fn(x0 + h) - fn(x0)) / h;
}

void demo1();
void demo2(const int, char*[]);

/**
    Функция *main* также может иметь параметры. Их должно быть ровно две штуки. Данные параметры
    служат для получения так называемых *аргументов командной строки*. Это аргументы, которые
    могут быть переданы программе при её запуске в терминале (консоли, командной строке). Там
    запуск программы выглядит следующим образом:
        |> prog_name.exe
    (имя программы вводится в текстовом виде, нажимается 'Enter').
    Но при этом вызов может выглядеть так:
        |> prog_name.exe arg1 345 56.778 arg4
    Всё, что идёт после названия программы, это и есть - аргументы командной строки. В программу
    на C++ они передаются в строковом виде (то есть, в выше приведённом примере даже числа *345*
    и *56.778* будут переданы в виде строк). Аргументы разделяются пробелами.

    Параметры функции *main* позволяют получить эти аргументы.
    Первый параметр - argc - это целое число, которое обозначает количество аргументов командной строки
    плюс 1. Для указанного выше примера argc == 5. Чуть ниже о том, почему "плюс 1".

    Вторым параметром идёт массив строк. Только не массив типа *string*, а именно строк в их базовом
    типе: массивах типа *char* с завершающим нулём('\0'). И первой строкой этого массива идёт !полный
    путь к запускаемому файлу!. То есть, argv[0] - всегда будет содержать полный путь и название того
    файла, в который была скомпилирована программа. А уже начиная со второго элемента (argv[1], argv[2],
    ...) идут сами аргументы.
*/
int main(int argc, char *argv[])
{
    /// Демонстрация работы с указателями на функцию
    demo1();

    /// Демонстрация работы с аргументами командной строки
    demo2(argc, argv);
}

void demo1()
{
    func_x fn_arr[] = {x_in_3, sin, cos};

    for (func_x fx : fn_arr) {
        cout << "f'(" << M_PI << ") = "
             << derivative(fx, M_PI) << endl;
    }
}

void demo2(const int argc, char* argv[])
{
    cout << "Путь и имя исполняемого файла: " << argv[0] << endl;

    if (argc > 1) {
        cout << "Аргументы командной строки: \n";
        for (int i = 1; i < argc; i++) {
            cout << "Аргумент " << (i+1) << " <<" << argv[i] << ">>\n";
        }
    }
}
