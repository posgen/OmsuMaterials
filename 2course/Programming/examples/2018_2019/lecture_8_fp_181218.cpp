#include <iostream>
#include <iomanip>
#include <cmath>
#include <string>
#include <algorithm>
#include <random>
#include <ctime>

using namespace std;

/**
    Создаётся псевдоним *fun_x_t* для типа: !указатель-на-функцию, принимающей один параметр
    действительного типа и возращающей какое-то значение того же самого типа.

    Тип возращаемого значения - это первый *double* справа от знака *равно*.
    Тип параметра - указан во вторых круглых скобках.
    *Звёздочка* в первых круглых скобках - специальная синтаксическая конструкция для
    обозначения типа *указатель-на-некоторую-функцию*
*/
using fun_x_t = double (*)(double);

/// Функция для проверки
double fun(double x)
{
    return x*x / 2.0;
}

/**
    Пример простейшего численного нахождения первой производной от функции
    одного аргумента.

    Функция принимает два параметра:
        *fn* - переменная-указатель типа *указатель-на-функцию одного параметра*.
               Сама по себе эта переменная и позволяет передать в функцию *derivative*
               любую другую функцию, которая принимает параметр типа *double* и возращает
               значение такого же типа.

        *x* - точка, в которой будет вычислена производная (любое действительное число)
*/
double derivative(fun_x_t fn, double x)
{
    const double h = 1.0E-8;
    /**
        Работа с переменной-указателем-на-функцию происходит аналогично вызову любой функции:
        к самой переменной применяют круглые скобки (которые, строго говоря, являются оператором
        в C++), в скобках указыаются нужные аргументы.

        Так, синтаксис *fn(4.0)* ничем не отличается от определённой выше функции fun: *fun(4.0)*.
        Но теперь, в данную функцию *derivative* могут попасть любые функции, соответствующие
        объявленному типу, а не одна конкретная, которая была определена заранее.
    */
    return (fn(x + h) - fn(x)) / h;
}

/// Вспомогательная структура для сохранения тестового названия функции и указателя на конкретную реализацию
struct FnWithDecl
{
    string decl;
    fun_x_t fn;
};


/**
    Далее следуют две функции, демонстрирующие работу ключевого слова *static* для переменных.

    *static* для любых переменных позволяет продлить им время жизни (сколько существует переменная
    в программе) до времени работы программы. В том числе это работает для локальных переменных
    внутри функций.

    Стандартно локальная переменная внутри функции создаётся во время работы функции и удаляется
    при её завершении.

    Синтаксически ключевое слово *static* добавляется при определении переменных до указания типа.
    И оно изменяет цикл жизни локальной переменной некоторой функции следующим образом:
        она создаётся только один раз. Не имеет значения, когда это будет - при начале работы
        программы (когда начинает исполняться функция *main*), или при первом вызове функции (внутри
        которой она определена) - это определяется компилятором. Важно именно то, что после определения
        такая переменная не будет удалена до окончания работы программы.

    static-переменный в русскоязычной литературе называют *статическими*.

    Одним из базовых примеров работы со static-переменными - это подсчёт количества вызовов какой-нибудь
    функции. Здесь не приведён, но был во время лекции показан.

    Ниже приводится пример расчёта факториала с приминением локальной static-переменной.
    Идея здесь в следующем: значения факториала от 1 до 20 будут вычисленны один раз,
    и при каждом последующем вызове функции вместо прохода по циклу и перемножения
    действительных чисел, будут загружены из определённого для этих целей массива.
    Такая техника оптимизации вычислений в функциях назвается *мемоизацией*.
*/
double fact(const size_t n)
{
    /**
        Заводим статический массив размера 21. Как и написано выше, он будет создан
        один раз. И его содержимое может меняться (а может и не меняться) при каждом
        вызове функции.

        Каждый элемент будет сохранять факториала от своего индекса. Схема:
            0! = 1
            1! = 1
            2! = 2
            3! = 6
            ...
        Так как значения для нуля и единицы определены, эти два значения запишем в первые
        два элемента (инициализация массива начальными значениями). При таком определении
        начальных значений, все остальные элементы получат значения 0.0.
    */
    static double values[21] = { 1.0, 1.0 };

    /**
        факториал не может быть равен нулю, этим и пользуется следующее условие:
            если нужен факториал для целого числа, меньше либо равного 20, и это
            значение уже было вычислено (не равно 0.0), то вернуть значение без новых
            вычислений.
    */
    if (n <= 20 and values[n] != 0.0) {
        return values[n];
    }

    /**
        если условие выше не выполняется, происходит стандартный расчёт факториала
        через цикл.
    */
    double res = 1.0;
    for (size_t i = 2; i <= n; i++) {
        res *= i;
    }

    if (n <= 20) {
        values[n] = res;
    }

    return res;
}

/**
    Ниже функция также демонстрирует static-переменные для более удобной работы с ГПСЧ
    из стандартной библиотеки C++. Если не использовать функцию *rand()* из <cstdlib>
    (которая не даёт достаточно хороший генератор псевдо-случайных чисел с точки зрения
    задач вычислительной физики), то работа с генераторами из библиотеки <random> строится
    следующим образом:
        1. Создать переменную конкретного типа, который представляет собой ГПСЧ. Например,
            mt19937_64 gener;
        2. Не забыть при создании как-то повлиять на то, чтобы при каждом запуске программы
        последовательность случайных чисел была разной:
            mt19937_64 gener( time(nullptr) );
        3. Помнить, что по умолчанию переменная генератора создаёт *целое* случайное число,
        как правило, равномерно распределённое в диапазоне [0, MAX_RND]
            gener()
        4. Для того, чтобы получить случайное число из диапазона [0.0; 1.0] проделать следующую
        работу:
            double( gener() ) / gener.max();
        (здесь случайное число приводится к действительному типу и делется на максимально возможное
        случайное число)

    Диапазон действительных чисел [0.0; 1.0] является более полезным, чем остальные (опять же, в выч. физике).
    Поэтому каждый раз правильно писать четвёртый пункт надоедает.

    Поэтому, разумным вариантом - создать функцию, в которой спрячется и ГПСЧ, и работа по расчёту случайного числа.
    Ниже функция для этого и написана, только не для диапазона [0.0; 1.0], а для более общего - [a; b],
    где a и b - любые действительные числа.
*/
double rand_a_b(double a, double b)
{
    /// Создаём генератор, переменная объявлена как static
    static mt19937_64 gnr{ time(nullptr) };
    /// Запоминаем максимально возможное число ГПСЧ, чтобы каждый раз
    /// не вычислять.
    static const size_t max_gnr = gnr.max();

    /// Стандартная формула для расчёта случайного числа в заданном диапазоне.
    return a + (b - a) * ( double(gnr()) / max_gnr );
}



int main()
{
    /******Демонстрация работы с указателями на функцию***********/
    FnWithDecl func_arr[] = {
        { "sin", sin },
        { "cos", cos },
        { "exp", exp },
        { "x^2 / 2", fun },
    };

    double x0 = M_PI;
    for (FnWithDecl elem : func_arr ) {
        double res = derivative(elem.fn, x0);
        cout << "Производная от " << elem.decl
             << " в точке " << x0 << " равна "
             << res << endl;
    }
    /*************************************************************/

    /**Демонстрация работы функций, использующих static переменные*/
    cout << "35! = " << fact(35) << endl;
    cout << "9! = " << fact(9) << endl;
    cout << "Ещё раз 9! = " << fact(9) << endl;
    cout << "И ещё 9! = " << fact(9) << endl;
    cout << "Случайное число от 0.5 до 12.5: " << rand_a_b(0.5, 12.5) << endl;
    cout << "Случайное число от 0.5 до 12.5: " << rand_a_b(0.5, 12.5) << endl;
    cout << "Случайное число от 0.5 до 12.5: " << rand_a_b(0.5, 12.5) << endl;
    /**************************************************************/
}
