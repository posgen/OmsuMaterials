#ifndef LIBLECT3_INCLUDED
#define LIBLECT3_INCLUDED

#include <cstddef>
#include <iterator>
#include <initializer_list>

/**
    Более-менее готовый класс, реализующий одномерный динамический массив
    с безопасной индексацией (любой переданный индекс отображается в диапазон [0; length),
    где length - длина массива).

    Предназначен для изучения основных аспектов ООП в C++, включая некоторые
    концепции стандартной библиотеки.
*/
class FP003Array
{
public:
    /**
        Конструктор по умолчанию.
    */
    FP003Array() = default;
    /**
        Конструктор с одним параметром, создающий динамический массив заданной длины.
        Присвоения элементам начального значения не происходит.
    */
    FP003Array(size_t arr_sz);
    /**
        Копирующий конструктор.
    */
    FP003Array(const FP003Array& other);

    /**
        Специальный конструктор, позволяющий создать динамический массив для
        конкретного набора значений.

        Технически, он добавляет инициализацию составных объектов к нашему классу:
            FP003Array arr1 = {1, 2, 3, 4};
            FP003Array arr2{8, 7, 6, 5, 4, 3, 2};
        *arr1* - массив на четыре элемента.
        *arr2* - массив на семь элементов.
    */
    FP003Array(const std::initializer_list<int>& lst) :
        data_{new int[lst.size()]}, length_{lst.size()}, capacity_{lst.size()}
    {
        size_t i = 0;
        for (int elem : lst) {
            data_[i] = elem;
            i++;
        }
    }

    /**
        Перемещающий конструктор.

        Параметр - ссылка на временный объект (либо - rvalue)
    */
    FP003Array(FP003Array&& other);

    /**
        Деструктор класса.

        Специальный метод, отвечающий за правильное освоождение используемой
        динамической памяти.
    */
    ~FP003Array();

    /**
        Копирующий и перемещающий операторы присваивания.
    */
    FP003Array& operator=(const FP003Array& rhs);
    FP003Array& operator=(FP003Array&& rhs);

    /**
        Перегруженные операторы индексации.
    */
    int& operator[](size_t index);
    // Специальная перегрузка для возможности использования констант
    // данного типа (как напрямую, так и в качестве параметров функций)
    const int& operator[](size_t index) const;

    /**
        Какой-то набор методов для работы с объектами класса.
    */
    int back() const;
    int front() const;
    size_t length() const;
    int pop();
    void push(int new_elem);

    /**
        Пример собственной реализации итератора для объектов созданного массива.

        А также - демонстрация того, что одни классы могут быть вложенными в другие.
    */
    class Iterator
    {
    public:
        /**
            Специальные объявления псевдонимов для того, чтобы различные функции стандартной
            библиотеки принимали этот итератор за своего.

            В порядке объявлений:
                1. Категория итератора. В данном случае - итератор произвольного доступа
                2. Тип элементов коллекции. Созданный массив служит для хранения целых чисел,
                   следовательно - *int*.
                3. Тип, определяющий количество элементов между двумя объектами итератора.
                   Должен быть знаковым. Поэтому - *int*.
                4. Указатель на тип из пункта 2.
                5. ССылка на тип из пункта 2.
        */
        using iterator_category = std::random_access_iterator_tag;
        using value_type = int;
        using difference_type = int;
        using pointer = int*;
        using reference = int&;

        /**
            Конструктор итератора - создаёт объект, который ссылается на элемент массива *obj*
            на позиции, определяемом индексом *idx*.
        */
        Iterator(size_t idx, FP003Array& obj);
        /**
            Копирующие методы.

            Итератор произвольного доступа должен быть копируемым. Поскольку в данной реализации
            была использована ссылка на массив (FP003Array&) в качестве поля объекта, по умолчанию
            C++ не может предоставить копирующие операции. Пришлось явно определять.
        */
        Iterator(const Iterator& other);
        Iterator& operator=(const Iterator& other);

        /**
            Сравнение объектов итераторов.

            Любой итератор произвольного доступа должен реализовать их все.
        */
        bool operator!=(const Iterator& rhs);
        bool operator==(const Iterator& rhs);
        bool operator<(const Iterator& rhs);
        bool operator<=(const Iterator& rhs);
        bool operator>(const Iterator& rhs);
        bool operator>=(const Iterator& rhs);

        /**
            Инкремент / декремент - все формы.
        */
        Iterator& operator++();
        Iterator operator++(int);
        Iterator& operator--();
        Iterator operator--(int);

        /**
            Доступ к элементам через разыменование итератора и индексацию
        */
        int& operator*();
        int& operator[](int n);

        /**
            Оператор вычитания двух объектов итератора.

            Строго говоря, типом возвращаемого значения должен быть *difference_type*,
            созданный псевдонимом выше. Но для краткости оставим просто *int*.
        */
        int operator-(const Iterator& rhs);

        /**
            Сложение/вычитание итератора с произвольным числом.

            По сути - смещение вправо/влево по итерируемой коллекции.
        */
        Iterator operator+(int n);
        Iterator operator-(int n);
        Iterator& operator+=(int n);
        Iterator& operator-=(int n);

    private:
        /**
            Поля итератора.
        */
        size_t index;
        FP003Array& arr_ref;
    };

    /**
        Специальные методы, возвращающие итераторы (объекты) на первый элемент (begin)
        и специальное значение (end), которое сигнализирует о том, что проход по коллекции
        завершился.
    */
    Iterator begin();
    Iterator end();

private:
    /**
        Поля для реализации динамического массива.
    */
    int *data_ = nullptr;
    size_t length_ = 0;
    size_t capacity_ = 0;

    void re_allocate();
};

#endif
